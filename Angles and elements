#include <iostream>
#include <iomanip>
#include <cmath>
#include <time.h>
#include <gsl/gsl_rng.h>	// GSL random number generators
#include <gsl/gsl_randist.h>	// GSL random distributions
#include <fstream>
#include <sstream>
#include "/Users/smcmillan/Documents/Physics/FlatteÃÅ Research/Code/MH Spin Relaxation/bsumtree.h"

using namespace std;


#define NX 100
#define NY 100
#define NZ 100
#define Pi 3.1415926535897932384626433832795028
#define HBar 1.0546 * pow(10,-34)
#define GammaSqr 1.07 * pow(10,-3)  //Alq3 electron polaron value (Yu)
#define Lambda 	sqrt(2 * 1.07 * pow(10,-3))  //Lambda = Sqrt(2*GammaSqr)
#define V	0.1 // in units of eV (Yu)

gsl_rng * rng_ptr;
//pointer to random number generator(rng)

double          random_exp(double a)
{
    return gsl_ran_exponential(rng_ptr, a);
}

double
random_gaussian(double sigma)
{
    return gsl_ran_gaussian(rng_ptr, sigma);
}

double
random_uniform()
{
    return gsl_ran_flat(rng_ptr, 0, 1);
}


//All V matrix elements are calculated with the following approx: vijx=vijy=vijz=V0

double
ModSqrVpp(double itheta, double iphi, double ftheta, double fphi)
{
    
    double MSvpp;
    
    MSvpp = pow(V,2.0) * (pow(sin(ftheta)*cos(fphi)*sin(itheta)*cos(iphi) + sin(ftheta)*sin(fphi)*sin(itheta)*sin(iphi) + cos(ftheta)*cos(itheta),2.0) + pow(-sqrt(2*1.07*pow(10,-3.0))*(sin(itheta)*cos(iphi)*sin(ftheta)*sin(fphi) - sin(itheta)*sin(iphi)*sin(ftheta)*cos(fphi)),2.0));
    return MSvpp;
}

double
ModSqrVmm(double itheta, double iphi, double ftheta, double fphi)
{
    double MSvmm;
    
    MSvmm = pow(V,2.0)*(pow(sin(ftheta)*cos(fphi)*sin(itheta)*cos(iphi) + sin(ftheta)*sin(fphi)*sin(itheta)*sin(iphi) + cos(ftheta)*cos(itheta),2.0) + pow(Lambda*(sin(itheta)*cos(iphi)*sin(ftheta)*sin(fphi) - sin(itheta)*sin(iphi)*sin(ftheta)*cos(fphi)),2.0));
    return MSvmm;
}

double
ModSqrVpm(double itheta, double iphi, double ftheta, double fphi)
{
    double MSvpm;
    
    
    MSvpm = pow(V,2.0)*(pow(-Lambda*(sin(itheta)*sin(iphi)*cos(ftheta) - cos(itheta)*sin(ftheta)*sin(fphi)),2.0) + pow(-Lambda*(cos(itheta)*sin(ftheta)*cos(fphi) - sin(itheta)*cos(iphi)*cos(ftheta)),2.0));
    return MSvpm;
}

double
ModSqrVmp(double itheta, double iphi, double ftheta, double fphi)
{
    
    double MSvmp;
    //check + sign between the squares and that v^2 multiplies all terms
    MSvmp = pow(V,2)*(pow(-Lambda*(sin(itheta)*sin(iphi)*cos(ftheta) - cos(itheta)*sin(ftheta)*sin(fphi)),2.0) + pow(-Lambda*(cos(itheta)*sin(ftheta)*cos(fphi) - sin(itheta)*cos(iphi)*cos(ftheta)),2.0));
    return MSvmp;
}

class Position
{
public:
    int             x, y, z;
    
    Position():	x(), y(), z() {
    };
    
    Position(int x_, int y_, int z_):x(x_), y(y_), z(z_) {
    };
};


class Vector
{
public:
    double          x, y, z;
    
    double          abs() {
        return sqrt(x * x + y * y + z * z);
    }
    
    Vector():                x(), y(), z() {
    };
    
    Vector(double x_, double y_, double z_):x(x_), y(y_), z(z_) {
    };
};


Position operator + (const Position & a, const Position & b) {
    return Position(a.x + b.x, a.y + b.y, a.z + b.z);
}

Vector operator + (const Vector & a, const Vector & b) {
    return Vector(a.x + b.x, a.y + b.y, a.z + b.z);
}

Vector operator - (const Vector & a, const Vector & b) {
    return Vector(a.x - b.x, a.y - b.y, a.z - b.z);
}

Vector operator / (const Vector & a, double d) {
    return Vector(a.x / d, a.y / d, a.z / d);
}

Vector operator * (double d, const Vector & a) {
    return Vector(a.x * d, a.y * d, a.z * d);
}

Vector operator * (const Vector & a, double d) {
    return Vector(a.x * d, a.y * d, a.z * d);
}

double operator *(const Vector & v, const Position & p) {
    return v.x * p.x + v.y * p.y + v.z * p.z;
}

double operator *(const Position & p, const Vector & v) {
    return v.x * p.x + v.y * p.y + v.z * p.z;
}

double operator *(const Vector & v, const Vector & p) {
    return v.x * p.x + v.y * p.y + v.z * p.z;
}

double
rate_for_E(double E, double k0)
{
    if (E < 0) {
        return k0;
    } else {
        return k0 * exp(- E);
    }
}

Vector outer(const Vector & a, const Vector & b)
{
    
    return Vector(a.y * b.z - a.z * b.y, a.z * b.x - a.x * b.z, a.x * b.y - a.y * b.x);
    
}

void
periodic(Position & pos)    // periodic boundary conditions for all directions
{
    
    if (pos.y < 0)
        pos.y += NY;
    
    if (pos.y >= NY)
        pos.y -= NY;
    
    
    if (pos.z < 0)
        pos.z += NZ;
    
    if (pos.z >= NZ)
        pos.z -= NZ;
    
    
    if (pos.x < 0)
        pos.x += NX;
    
    if (pos.x >= NX)
        pos.x -= NX;
    
}

int
main(int argc, char *argv[])
{
    
    clock_t t1,t2;
    t1=clock();
    
    
    rng_ptr = gsl_rng_alloc(gsl_rng_taus2);
    //allocate the rng
    gsl_rng_set(rng_ptr, 5);
    //seed the rng
    
    //string input;
    double k;
    double SIGMA;
    int NDIS;
    int max_hops;
    
    cout << "Enter hopping rate (in units of hf), k0: ";
    cin >> k;
    cout << "Enter the disorder (in units of T), sigma: ";
    cin >> SIGMA;
    cout << "Enter the number of disorder configurations to average over: ";
    cin >> NDIS;
    cout << "Enter the maximum number of hops: ";
    cin >> max_hops;
    
    std::ostringstream strs1; //convert doubles into strings
    strs1 << k;
    std::string input1 = strs1.str();
    std::ostringstream strs2;
    strs2 << SIGMA;
    std::string input2 = strs2.str();
    std::ostringstream strs3;
    strs3 << NDIS;
    std::string input3 = strs3.str();
    std::ostringstream strs4;
    strs4 << max_hops;
    std::string input4 = strs4.str();
    
    std::ofstream out_file;
    out_file.open(("k"+input1+"s"+input2+".dat").c_str());
    cout << "The output file is " << "k"+input1+"s"+input2+".dat" << endl;
    
    //  double          BFIELD = 0;
    //  double          GAMMA = 0.025;
    double		k0	= k/6.;
    int 		state = 1;
    
    
    
    int HOPS;
    
    Position hops[] = {
        Position(1, 0, 0), Position(-1, 0, 0), Position(0, 1, 0),
        Position(0, -1, 0), Position(0, 0, 1), Position(0, 0, -1)
    };
    
    
    
    double time, tOld, tNew, angle;
    
    double time_max;
    double dt;
    
    
    for (int id = 0; id < NDIS; id++) {
        
        HOPS = 1;
        
        double        sim_time = 0;
        
        /*	Vector spin(0, 0, 1);
         Vector spinOld(0, 0, 1);
         Vector spinNew(0, 0, 1);
         */
        
        double ***theta = new double**[NX];
        double ***phi = new double**[NX];
        double ***energy = new double**[NX]; // dynamic allocation for site energies
        //	Vector ***Bfield = new Vector**[NX];
        
        
        for (int ix = 0; ix < NX; ix++) {
            
            theta  [ix] = new double*[NY];
            
            phi  [ix] = new double*[NY];
            
            energy  [ix] = new double*[NY];
            
            //		Bfield[ix] = new Vector*[NY];
            
            
            for (int iy = 0; iy < NY; iy++) {
                
                theta  [ix][iy] = new double[NZ];
                
                phi  [ix][iy] = new double[NZ];
                
                energy  [ix][iy] = new double[NZ];
                
                //			Bfield[ix][iy] = new Vector[NZ];
                
                for (int iz = 0; iz < NZ; iz++) {
                    
                    
                }
                
            }
            
        }
        
        
        for (int x = 0; x < NX; x++) {
            
            for (int y = 0; y < NY; y++) {
                
                for (int z = 0; z < NZ; z++) {
                    
                    theta[x][y][z] = random_uniform()*2*Pi;
                    
                    phi[x][y][z] = random_uniform()*Pi;
                    
                    //	energy[x][y][z] = random_gaussian(SIGMA);   // this is DOS
                    energy[x][y][z] = -random_exp(SIGMA);   // this is EDOS
                    
                    //rand
                    //				Bfield[x][y][z].x = random_gaussian(GAMMA);
                    
                    //				Bfield[x][y][z].y = random_gaussian(GAMMA);
                    
                    //				Bfield[x][y][z].z = random_gaussian(GAMMA);
                    
                }
            }
        }
        
        
        
        s_bsumtree prob_tree; // wieghting starting points on y-z plane with Boltzmann factors (more likely for spin to start in lower energies)
        prob_tree.init(NY*NZ);
        
        for (int y = 0; y < NY; y++) {
            for (int z = 0; z < NZ; z++) {
                double prob = 1;
                //double prob = exp(energy[0][y][z]);
                prob_tree.setelement(y + NY*z , prob);
            }
        }
        
        double tot_prob = prob_tree.compute_sum();
        double randn = random_uniform();
        double rand_prob = randn*tot_prob;
        
        int index = prob_tree.search(rand_prob);
        int y = index % NY;
        int z = index / NY;
        
        Position pos(0, y, z);
        
        
        while (HOPS < max_hops + 1) {
            
            //make time step
            
            //make rates
            
            double *rates;
            rates = new double[12]; //two matrix elements per NN
            
            double          total_rate = 0;
            
            //make rates from V matrix using Fermi's golden rule
            double *Vrate;
            Vrate = new double[12];
            int n = 0;
            
            for (int r = 0; r < 6; r++) {
                
                Position target = pos + hops[r];
                
                periodic(target);
                
                if (state == 0){
                    Vrate[n] = ModSqrVpp(theta[pos.x][pos.y][pos.z], phi[pos.x][pos.y][pos.z], theta[target.x][target.y][target.z], phi[target.x][target.y][target.z]);
                    
                    rates[n] = 2*Pi/HBar * Vrate[n] * rate_for_E(energy[target.x][target.y][target.z] - energy[pos.x][pos.y][pos.z], k0);
                    
                    cout << "Vpp is " << rates[n]<< ".   ";
                    
                    total_rate += rates[n];
                    
                    n++;
                    
                    Vrate[n] = ModSqrVmp(theta[pos.x][pos.y][pos.z], phi[pos.x][pos.y][pos.z], theta[target.x][target.y][target.z], phi[target.x][target.y][target.z]);
                    
                    rates[n] = 2*Pi/HBar * Vrate[n] * rate_for_E(energy[target.x][target.y][target.z] - energy[pos.x][pos.y][pos.z], k0);
                    
                    cout << "Vmp is " << rates[n] << endl;
                    
                    total_rate += rates[n];
                    
                    n++;
                }
                else if (state == 1){
                    Vrate[n] = ModSqrVmm(theta[pos.x][pos.y][pos.z], phi[pos.x][pos.y][pos.z], theta[target.x][target.y][target.z], phi[target.x][target.y][target.z]);
                    
                    rates[n] = 2*Pi/HBar * Vrate[n] * rate_for_E(energy[target.x][target.y][target.z] - energy[pos.x][pos.y][pos.z], k0);
                    
                    cout << "Vmm is " << rates[n]<< ".   ";
                    
                    total_rate += rates[n];
                    
                    n++;
                    
                    Vrate[n] = ModSqrVpm(theta[pos.x][pos.y][pos.z], phi[pos.x][pos.y][pos.z], theta[target.x][target.y][target.z], phi[target.x][target.y][target.z]);
                    
                    rates[n] = 2*Pi/HBar * Vrate[n] * rate_for_E(energy[target.x][target.y][target.z] - energy[pos.x][pos.y][pos.z], k0);
                    
                    cout << "Vmp is " << rates[n] << endl;
                    
                    total_rate += rates[n];
                    
                    n++;
                }
                else {
                    cout << "Error in state variable!" << endl;
                }
                
            }
            
            //choose hop:
            
            double          rand_rate = random_uniform() * total_rate;
            int             ihop;
            
            for (ihop = 0; ihop < 12; ihop++) {
                
                if (rand_rate < rates[ihop])
                    
                    break;
                
                
                rand_rate -= rates[ihop];
                
            }
            
      
            
            //ihop is chosen hop
            
            
            // if ihop 0 or even state = 0, if odd state = 1
            
            cout << "ihop is " << ihop << ".  ";
            
            if (state == 0){
                if (ihop == 0 || ihop == 2 || ihop == 4 || ihop == 6 || ihop == 8 || ihop == 10){
                    state = 0;
                    cout << "New state value is " << state << endl;
                }
            
                if (ihop == 1 || ihop == 3 || ihop == 5 || ihop == 7 || ihop == 9 || ihop == 11){
                    state = 1;
                    cout << "New state value is " << state << endl;
                }
            }
            
            else if (state == 1){
                if (ihop == 0 || ihop == 2 || ihop == 4 || ihop == 6 || ihop == 8 || ihop == 10){
                    state = 1;
                    cout << "New state value is " << state << endl;
                }
                
                if (ihop == 1 || ihop == 3 || ihop == 5 || ihop == 7 || ihop == 9 || ihop == 11){
                    state = 0;
                    cout << "New state value is " << state << endl;
                }
            }

            
            // Revalue ihop so that it indicates the correct target when used as the argument of hops[]
            
            if (ihop == 0 || ihop == 1){
                ihop = 0;
            }
            
            if (ihop == 2 || ihop == 3){
                ihop = 1;
            }
            
            if (ihop == 4 || ihop == 5){
                ihop = 2;
            }
            
            if (ihop == 6 || ihop == 7){
                ihop = 3;
            }
            
            if (ihop == 8 || ihop == 9){
                ihop = 4;
            }
            
            if (ihop == 10 || ihop == 11){
                ihop = 5;
            }
            
            Position target = pos + hops[ihop];
            
            periodic(target);
            
            double Sz;
            
            //Calculate Spin along z
            
            if (state == 0){
                
                Sz = 1 - GammaSqr * pow(cos(theta[target.x][target.y][target.z]),2);
            }
            
            else if (state == 1){
                
                Sz = -(1 - GammaSqr * pow(cos(theta[target.x][target.y][target.z]),2.0));
            }
            
            else {
                cout << "No Sz data recorded. State value is"<< state << endl;
            }
            //precess spin:
            
            time = random_exp(1.0 / total_rate);
            //exp rand
            tNew = sim_time + time;
            
            //Vector B(random_gaussian(GAMMA), random_gaussian(GAMMA), random_gaussian(GAMMA)); // MH w/ no field correlations
            //	Vector B = Bfield[pos.x][pos.y][pos.z]; // MH
            //	Vector rot_axis = B / B.abs();
            
            //	angle = B.abs();
            
            tOld = sim_time;
            //	spinOld = spin;
            
            sim_time = tNew;
            
            //spinNew = (1 - GAMMA * GAMMA) * spinOld;
            //	spinNew = ((1 - cos(angle)) * (spinOld * rot_axis)) * rot_axis + cos(angle) * spinOld +sin(angle) * outer(rot_axis, spinOld);
            
            //for linear sampling
            time_max = 100.;
            dt = 1.;
            
            for (double t = 0.01; t <= time_max; t+= dt) {
                
                if (t >= tOld && t < tNew) {
                    
                    //	cout << t << " " << tOld << " " << tNew << " " << Sz << endl;
                    out_file << t << "\t" << Sz << std::endl;
                    
                }
                
                //	 spin = spinNew;
            }//*/
            
            // for log sampling
            double x = 5.; // sampling time logarithmically
            double dx = 0.5;
            
            //	for (double t = dx; t <= x; t+= dx) {
            /*		for (double t = dt; t <= x; t+= dx) {
             
             
             if (pow(10,t) >= tOld && pow(10,t) < tNew) {
             
             //	cout << t << " " << tOld << " " << tNew << " " << Sz << endl;
             out_file << pow(10,t) << "\t" << Sz << std::endl;
             
             
             }
             else {
             //spinNew = spinOld;
             }
             
             if (pow(10,t) >= tNew) {// get out of loop and go to next hop
             //	break;
             }
             
             spin = spinNew;
             
             //	cout << t << " " << tOld << " " << tNew << " " << spin << endl;
             }//*/
            
            //perform hop:
            
            
            
            
            
            
            
            pos = target;
            
            
            HOPS++;
            
            delete [] rates;
            
        }
        
        //////////////Bug Check Output Statements////////////////////
        
        //cout << "The Sine of Pi is " << sin(Pi) << endl;
        //cout << "The Cosine of Pi is " << cos(Pi) << endl;
        //cout << "The theta value at point [2][3][6] is " << theta[2][3][6] << endl;
        //cout << "The phi value at point [2][3][6] is " << phi[2][3][6] << endl;
        //cout << "The Energy value at point [20][30][65] is " << energy[20][30][65] << endl;
        //cout << "The Energy value at point [2][3][6] is " << energy[2][3][6] << endl;
        
        
        /////////////////////////////////////////////////////////////
        
        
        for (int ix = 0; ix < NX; ix++) {    // deallocation of energy memory
            for (int iy = 0; iy < NY; iy++) {
                delete[] theta[ix][iy];
                delete[] phi[ix][iy];
                delete[] energy[ix][iy];
                //		delete[] Bfield[ix][iy];
            }
            delete[] theta[ix];
            delete[] phi[ix];
            delete[] energy[ix];
            //	delete[] Bfield[ix];
        }
        delete[] theta;
        delete[] phi;
        delete[] energy;
        //	delete[] Bfield;
        
    }
    
    out_file.close();
    
    
    std::cout << "(NX,NY,NZ) = " << "\t (" << NX<<", "<<NY<<", "<<NZ<<")" << std::endl;
    std::cout << "disorder configs = " << "\t" << NDIS << std::endl;
    std::cout << "k0 = " << "\t" << 6. * k0 << std::endl;
    std::cout << "sigma = " << "\t" << SIGMA << std::endl;
    
    
    //	std::cout << std::endl << "X\tpol" << std::endl;
    
    
#ifdef WIN32
    char            c;
    std::cin >> c;
#endif	/*
*/
    
    gsl_rng_free(rng_ptr);
    //free the random number generator
    
    t2=clock();
    float diff ((float)t2-(float)t1);
    float seconds = diff / CLOCKS_PER_SEC;
    std::cout<< "timer:\t" << seconds<< " seconds"<<std::endl;
    std::cout<< "length of table = \t" << (HOPS - 1) * NDIS << " "<<std::endl;
    // system ("pause");
    
    return 0;
    
}
